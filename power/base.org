#+title: 知识

* 散                      ---- 散装知识
** LOOP reactor 加 buffer 是否等于适配成 proactor


* 理论知识多看书           ---- 信息差，有时候你想不出来，不是你不聪明，只是信息不够，逻辑无法自恰 
** 计算机网络


** 计算机体系结构
*** DONE 指令系统简介，（诞生，与其他模块的关系等）
DEADLINE: <2022-10-05 Wed 09:55> SCHEDULED: <2022-10-05 Wed 08:50>
- 处理器架构，指令集，具体CPU型号 的 关系
  https://www.zhihu.com/question/23474438
  https://www.cnblogs.com/leinuo2016/p/16214796.html
  https://www.zhihu.com/question/349437202


*** DONE 指令系统组成
hen 


*** DONE 二进制与数字逻辑电路
DEADLINE: <2022-10-04 Tue 08:30> SCHEDULED: <2022-10-04 Tue 08:00>
- 二进制表示
  - 原码与补码与定点数
  - 浮点数
    - 符号
    - 阶码
    - 尾数
- 数字逻辑电路
  - 组合逻辑
    没有存储单元，输入什么，就输出什么。
    - 应用
      - 门：与，或，非，与非，或与，异或
      - 加法器，选择器
  - 时序逻辑
    具有存储单元，不再是组合逻辑一样的输入输出，而是利用存储功能，达到开关的目的。

    - 时钟信号与高低电位与 C 控制器
      电信号控制
    - RS 锁
      上下两个 *与非门* 组成的蝴蝶结，基础组件
    - D 锁存器
      在 RS 锁存器的基础上，添加 （1） 两个与非门  （2） C 控制器 控制 D 输入
      - C = 0 ： 保持（保持的意思是不论 D 输入怎么变化，输出都保持原来的状态）
      - C = 1  ： 直通

      通过 C 控制器（时钟信号）控制 D 输入，使得 RS 能够像蓄水池一样，达到一个 *存储* 的假象，从而能够作为 *开关*
    - D 触发器
      两个 D 锁存器组成
      - C=0
	第一个锁存器直通，第二个保持
      - C=1
	第一个保持，第二个直通
      - C 从 0 变成 1
	D 的值被锁起来了
  - CMOS 电路
    讲点具体的，不管是组合逻辑电路还是信号逻辑电路，都是 CMOS 电路（电工知识吧？可能比较安全省电）。



*** DONE 简单运算器设计
DEADLINE: <2022-10-04 Tue 10:00> SCHEDULED: <2022-10-04 Tue 08:40>
- 基础背诵
  CPU 内负责的组件叫做算术逻辑单元（ALU）
  - 算术运算
  - 逻辑运算
  - 比较运算
  - 移位运算
  - 乘，除，开方
- 定点补码加法器
  - 基础之：一位全加器

  ...
  加法进位是加法器的核心，根据进位的处理方式不同，进行分类
  - 类别1 ：行波进位加法器
  - 类别2 ：先行进位加法器

    
*** DONE 总线设计
DEADLINE: <2022-10-04 Tue 12:00> SCHEDULED: <2022-10-04 Tue 10:43>
- 总线定义
  不仅用于传输信号，还是软件同硬件架构的桥梁
- 总线架构层级
  - 机械层：接口外形，尺寸
  - 电气层：信号描述，电源电压，电平标准
  - 协议层：信号时序，握手协议，命令格式，出错处理
  - 架构层：软件架构和硬件模块
- 划分：根据那个信号
  - 串行
  - 并行
- 划分：根据物理位置进行划分
  - 片上总线：芯片内模块（例如处理器芯片上：处理器核，内存控制器等多个模块）之间的总线
  - 内存总线：处理器与主存储器之间的主线
  - 系统总线：处理器与桥卡之间，或多个处理器相连成并行处理器
  - 设备总线：处理器与 IO 设备之间


*** DONE 片上总线
DEADLINE: <2022-10-04 Tue 16:00> SCHEDULED: <2022-10-04 Tue 14:10>
片上总线是 芯片内部模块， （处理器上芯片：处理器核，内存控制器，缓存）等之间的总线
- AXI 协议
  1. 主从单向流通
  2. 控制（版本）信息与数据分离
- AXI 架构
  - 单架构
    读写
  - 互连架构
    每个主设备都可以访问从设备
- 事务
- 其他总线
  ASB，ASP 等，是典型的共用单通道
  但是片上总线要求的是并行性，所以具有分离通道的 AXI 脱颖而出。
- 通过AXI总线互连架构连接 高性能CPU的组件
  主设备：  CPU 核   CPU 核   CPU 核
          (9)       (9)     (9)
                AXI 总线
		   （9）
	        最后缓存
	  （9）	   （9）    （9）
                AXI 总线
	  （9）     （9）    （9）
       内存控制器   内存控制器   内存控制器
       

* 实战项目                 ---- 多练习
** Pygame 贪吃蛇
*** DONE Pygame贪吃蛇：基本逻辑与代码运行
DEADLINE: <2022-10-04 Tue 21:00> SCHEDULED: <2022-10-04 Tue 19:18>
[[~/code/write/贪吃蛇/main.py]]
- 第一次写完整的业务逻辑
  - 写业务逻辑和写底层是两回事，我终于意识到过去用 C++ 写逻辑为啥老是失败和那是多么可笑的事情，因为根本不适合。
  - 写逻辑的时候，就要专注业务逻辑，不要在意为啥是这样生成随机数，那不是应该关心的
- 第一次写业务逻辑的大致流程（框架），别管琐碎的东西
  1. 开启框架
  2. 设置一堆乱七八糟的东西，字体，颜色等等（靠，查资料）
  3. 数据结构也许没有那么重要（贪吃蛇用列表，坐标用元祖）
  4. 开启 While （） 循环，循环内是监听用户按键，并且变更外部的状态（在这里是方向键）
  5. While （） 后，判断 While（） 里面被改变的状态
  6. 更新里面数据结构（蛇的长度和位置，草莓的位置）
  7. 把更新的数据结构显示在屏幕，并且设置 FPS 刷新率

  : 6 和 7 解决我一个疑问，我以前是在 While （） 里面刷新屏幕。
  : 其实更好的做法是只在 While（1） 监听用户按键，然后更新数据结构。在 While（）结束后，才把更新的数据结构显示在屏幕上
  : 同时刷新 FPS，以控制节奏（我以前是在 While（） 里面 sleep() ）


*** DONE Pygame贪吃蛇：练习 1
DEADLINE: <2022-10-04 Tue 22:10> SCHEDULED: <2022-10-04 Tue 21:10>
[[~/code/write/贪吃蛇/main2.py]]
- 绘制是一件很重要的事情，要是不上色，那就会全黑
- 基本逻辑都能搞懂
- 疑问
  - 为啥要记录变量
- 缺失的逻辑
  - 绘制
  - 碰到自己或墙壁
  - 苹果的更新（随机生成）逻辑
  - 游戏结束


*** DONE Pygame贪吃蛇：练习 1 纠错与改正
DEADLINE: <2022-10-05 Wed 11:30> SCHEDULED: <2022-10-05 Wed 10:31>
[[~/code/write/贪吃蛇/main2.py]]
- 补全缺失的逻辑 [4/4]
  - [X] 绘制
  - [X] 碰到自己或墙壁
  - [X] 苹果的更新（随机生成）逻辑
  - [X] 游戏结束
- Bug [4/5]
  - [ ] 无法监听用户的方向按键
    - [ ] 原因猜测
      - [ ]
    - [ ] 真正原因
  - [X] 启动后，无法绘制的问题
    - [X] 猜测原因
      - [X] 缺失关键启动逻辑
      - [X] 颜色变量定义错误
      - [X] 颜色变量传递失误
    - [X] 真正的原因
      - 逻辑错误
	我把贪吃蛇数据结构和苹果的绘制逻辑，写出了 While 循环
      - 怎么影响程序的
	陷入 While 监听用户命令的循环中，从而使绘制逻辑，无法实现。
      - 反思
	所以，在 While 逻辑中，
	1. 监听用户，并且改变数据结构
	2. 根据改变的数据结构绘制逻辑
	3. 设置 Fps，相当于以前的 Sleep
  - [X] 贪吃蛇的数据结构溢出：写错
  - [X] 没有导入 Time 模块
  - [X] 变量名写错



** Android 客户端与聊天软件
*** DONE 安卓 im 软件的问题定义与需求分析
DEADLINE: <2022-09-19 Mon 11:31> SCHEDULED: <2022-09-19 Mon 09:31>
- 背景
  网络工程《软件工程》课程实训项目。
- 功能描述
  - Android UI 界面与逻辑
    Android 客户端除了编写用户界面与逻辑，对接服务器端
  - 登录服务器与图片服务器
    1. 提供用户注册，登录，注销功能。
    2. 除了用户编写信息外，图片服务器还允许用户上传头像等 PNG 图片。
    3. 心跳功能，维持用户在线状态与检查用户是否在线，是否踢掉用户。
  - 文件 FTP 服务器
    为用户提供传输文件服务
  - 聊天服务器
    1. 1 V 1 添加好友，显示好友是否在线，聊天功能。
    2. 群聊功能
- 硬件环境，软件环境
  - 服务端生产环境
    操作系统：Linux x64 Debian10
    数据库： Sqlite
    编程语言：使用 C 编写底层的网络服务，上层使用 Python 编写业务逻辑。目前考虑单机，以后可能扩展为分布式。
  - 客户端环境
    目前只支持 Android 端，服务器允许使用命令行 telnet 进行网络调试。


*** DONE 使用 Python 写服务器端的网络框架了解:Gevent
DEADLINE: <2022-09-19 Mon 21:30> SCHEDULED: <2022-09-19 Mon 22:30>
- 如何使用
  - 虽然 Gevent 依赖与 Greenlet。但是对于用户来说，并没有直接使用 GreenLet，而是直接使用 Gevent 的封装。
  - 只用设置一个启动的回调，然后就直接在这个启动函数写逻辑代码，连接开关和读写。不用像 Muduo 一样设置读，写，连接回调分割业务逻辑。
- 依赖与相关模块
  : use greenlet to provide a high-level synchronous API on top of libev event loop.
  : greenlet 负责提供协程调度，而 Libev 提供异步回调接口。
  - greenlet
    - QUESTION
      + 是否是内置模块？
	不是，Greenlet 依旧是一个第三方模块，通过 C 扩展实现协程。
      + Python 的协程通过第三方库实现，难道没有一套内置的线程 / 协程实现吗？
	？？
    -
  - Libev
- 源码阅读


*** DONE Python 网络编程入门之 GIL 锁与协程的发展
DEADLINE: <2022-09-20 Tue 10:40> SCHEDULED: <2022-09-20 Tue 07:40>
- Python 多线程
  - GIL 锁

    - 为什么引入？
      为了实现线程安全的引用计数，Python 的 GC 实现是类似 C++ shared_ptr 一样的引用计数，所以为了保证全局更新所有变量的引用计数，所以必须引入一个全局锁。
      : 也就是说 GIL 锁的本质是 Python 的 GC 引起的。

    - 缺点
      - 全局引起的 *无法利用多核*
	即时有多个 CPU 依旧无法利用多核优势

      - 粗粒度锁，依旧无法做到 *线程安全*
	虽然，GIL 锁限制了只有一个 CPU / (执行单元) 访问变量。
	但是这个锁的粒度并非像以前的 C++ mutex 一样，由程序员进行控制。
	换句话说，很多 Python 的操作并不是原子的，依旧不是线程安全的。

- 协程
  - 生态的发展
    因为多线程的羸弱，Python 把注意力集中在协程上。事实上，在 Golang 协程问世前，Gevent 就早已经声名鹤起。

    - 带来的优势
      1. 已经积累了大量的协程框架和协程服务。
      2. 文件与数据库
	 异步框架都只是涉及到网络部分，而 Python 经过多年的发展很多地方均已协程化。

  - 底层协程化
    ？？

  - 模块
    - 标准库
    - 老牌的协程 Gevent


*** DONE Python 如何利用多核？
DEADLINE: <2022-09-20 Tue 11:50> SCHEDULED: <2022-09-20 Tue 10:50>
- 多线程 （ERROR）
  python 多线程因为 GIL 锁的原因无法利用多核。

- 协程   （ERROR）
  协程只是把 selector 等异步事件同步化。但是依旧没有解决多核的问题。

- 多进程 + 协程/(异步reactor)（RIGHT）
  其实算是曲线救国，因为
  - 那些书本中拿协程取代多线程的例子是错的。
    因为在服务器中，使用多线程的目的在于利用多核。
    把多线程改成协程，并不能利用多核优势。
    如果这样做只是为了不阻塞应用，那说明这个例子本身就是错误的示范，正确的例子是单线程异步模型 + 多线程 Loop。

    所以，这个例子顶多说明了 *协程* 可以简化 *单线程的异步模型* ，让 Python 可以不阻塞应用。（虽然本来也可以异步模型，只是麻烦）

    : 说明 Python 可以不用线程而用协程做到不阻塞（虽然这样用线程是错误的）。但是忽视了线程的重要作用：利用多核。
  - 比较好的书籍笔记节选
    不过也不需要那么悲观，Python提供了其他方式可以绕过GIL的局限，比如使用多进程multiprocessing模块或者采用C语言扩展的方式，以及通过ctypes和C动态库来充分利用物理内核的计算能力。


*** DONE Python 深入 From《流畅 Python》：理解 Python 的数据模型
DEADLINE: <2022-09-20 Tue 16:30> SCHEDULED: <2022-09-20 Tue 14:30>
- Python 数据模型非常牛



*** DONE Python 协程入门
DEADLINE: <2022-09-20 Tue 20:30> SCHEDULED: <2022-09-20 Tue 17:30>


*** DONE Python 多线程与多进程
DEADLINE: <2022-09-21 Wed 10:00> SCHEDULED: <2022-09-21 Wed 08:00>


*** DONE POSTGRESQL
: from 七周七數據庫
  - 命令行
    1. 創建數據庫：createdb xxoo
    2. 進入數據庫: psql xxoo (使用 psql)
  - SQL 語句
    - 屬性類型
      - 字符串
	- varchar(9) ： 長度可以達到 9 個字節
	- char(2)    ： 正好要存儲 2 個字節
	- text    ： 任意長度
    - 修飾符
      - Primary Key：主鍵，具有唯一性約束，可以設置 *定義的兩個屬性* 爲主鍵
	+ 如果不指定主鍵會怎麼樣？
      - UNIQUE ：讓除了 Primary Key 外的其他列（屬性） 具有唯一性
      - NOT NULL ： 不能爲空
      - CHECK （指定約束）   ： 指定約束
      - REFERENCE 表： 外鍵約束，該屬性能夠引用另一張表
    - CRUD
      - CREATE TABLE xxoo (name 類型 屬性，);
      - SELECT * from xxoo;
      - INSERT INTO xxoo VALUE （'','',''# 直接輸入值就行了）
      - UPDATE xxoo SET xx=yy WHERE xx=yy


** TASK 用 python 重写野火 im 的服务器端


* 领域技能                 ---- 深入具体的领域
** TASK RPC 


** TASK android


* 设计语言                 ---- 能力表达的最前端，什么网络编程，什么高并发，表达不出来什么都是假的。
** TASK C 


** Python
*** DONE python 异步编程的发展史
DEADLINE: <2022-11-08 Tue 16:45> SCHEDULED: <2022-11-08 Tue 16:30>
:LOGBOOK:
CLOCK: [2022-11-08 Tue 16:31]--[2022-11-08 Tue 16:48] =>  0:17
:END:
- [X] 异步回调时代
  可以追溯到 python2
    - [X] swisted
    - [X] tongo
- [X] 协程时代
  : Python 很早就开始大规模使用协程
    - [X] Python 3.4
        - [X] yield 生成器模拟步进 next()
        - [X] Gevent : greenlet 和 libev 结合
          没有内置的同步原语，就是 monkey Patch 替换

    - [X] python 3.5：从标准网络库和原语发展
        - [X] asyncio
        - [X] async/await
          底层是 yield, 所以好好了解下 yield，非常有必要

    - [X] 全面协程化（除了网络）
      社区，借助 async/await 原语，与类似 asyncio 的数据库 io 复用结合，诞生了数据库连接的协程库，

        - [X] aiomysql

        - [X] aiohttp: 进一步封装 asyncio 作为 http 服务器


*** DONE CYthon 的底层原理
DEADLINE: <2022-11-23 Wed 16:00> SCHEDULED: <2022-11-23 Wed 14:00>
:LOGBOOK:
CLOCK: [2022-11-23 Wed 16:15]--[2022-11-23 Wed 17:36] =>  1:21
:END:
-----------------------------------------------------
- [X] 任务目标
  根据 socket 模块的 gethostname 的延伸，为啥标准库 lib/python/ 里面没有 def gethostname 的源代码，不得不想联想到和 c 的关系
-----------------------------------------------------
- [X] https://awesome-programming-books.github.io/python/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf
------------------------------------------------------
- [X] Cython gethostname() 解释工作的原理？
  背后有一个 c 函数，Python 解释器去调用 c 函数
- [X] 怎么看 cpython 的解释器源码 / 如何看待 gethostname 对应的 c 代码扩展？
- [X] 到底是特殊的 c 模块翻译成 py? 还是 py 所有语句都翻译成 c 模块
  都不是，而是底层虚拟机根据上层的解析后的 py 代码分词作出指令，而虚拟机是 c 写的，所以当然最后是 c 代码。这里的低效是上层 py 代码的低效，而 c 模块直接调用不需要虚拟机的翻译过程
- [ ] 怎么通过 c 代码扩展 python?



*** python 官方文档
**** DONE 大纲
:LOGBOOK:
CLOCK: [2022-11-11 Fri 08:00]--[2022-11-12 Sat 18:31] => 34:31
:END:
: 为什么是最高优先级，因为我看文档比看任何垃圾博客，看任何书要高效，对程序员的锻炼更好，王勇大哥就是这样进步来的。
: 不是要过面试吗？看什么书都不如看官方文档，所以最高优先级给到官方文档
-----------------------------------------------------
- [X] 任务目标
  全方位的学习 Python
-----------------------------------------------------
- [X] https://docs.python.org/zh-cn/3/contents.html
- [X] [[~/code/python教材/]]
------------------------------------------------------


**** TASK 上下文管理



**** TASK 数据结构


**** TASK socket 


* 工具篇                   ---- 人类为何崛起
** TASK Git


** Emacs
*** TASK 写一个 eaf-code-search
